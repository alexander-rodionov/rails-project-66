По 3 и 4 изменил, беру единственный язык и проверяю по нему.

По 7 все еще есть непонимание.

1. С какой целью мне стабать отдельно bash runner? Если я правильно понял затею из обрацового проекта, он обертывает PTY.spawn, который у меня Open3.capture.
У меня он используется в трех местах: при вызове git clone, при вызове rubocop и eslint. В случае с git clone вернуть 0 это решение. Хорошо. Но в случае с eslint и rubocop этого не достаточно, поскольку они оба возвращают json, который следом парсится. Если они просто вернут 0 и пустую строку в stdout, то разбор упадет и смысла от такого стаба нет. Логично отдельно стабать git clone и возвращать 0, а отдельно каждый линтер, и возвращать ожидаемый json, чтобы и не падало, и протестировать разбор. Смысл то все это этого мероприятия в том, чтобы тест функциональности сделать ведь.

А зачем стабать сам вызов команды все же не понимаю. Вот если бы у меня были бы три разных git вызова, и еще два docker вызова, тогда застабать Open3.capture имело бы смысл. Но тогда совершенно не имело бы смысл стабать и все эти команды, раз механизм выполнения уже застабан и возвращает успах на тестах.


2. Похожий вопрос про стаб целиком github client. Октокит стабать кажется правильной идеей, я полагаюсь на авторов октокита и считаю, что его тестировать не надо, он и так хороший. Но в github client есть 150 строчек кода, который из того, что вернул октокит получает то, что нужно мне: слайсит, мэпит и проверяет какие-то значения. Если я его застабаю целиком, то получается я эту логику убираю из скоупа тестирования, причем без видимой причины.


3. Про нейминг и структуру классов тоже есть вопрос. В сервисах лежат интеракторы. ОК, принято. Интерактор реализует один use case какой-то. Но мы же не можем совсем лишиться классов в привычном понимании, в смысле у которых есть пачка методов, какое-то внутреннее состояние, иерархия и связи. Вот например тот же Github::Client. Оне не одно бизнес действие выполняет. Он реализует ряд операций вокруг работы с github, которые вызываются из реализации бизнес операций. И такого много же может быть. Практически все рельсы это вот такие классы. И никак к паттерну интерактора все это богатство не получится свести.
Ну я так понял, что таким классам место в lib, а не в services и перенес его туда. Надеюсь правильно.

Дальше идем к стабам.

Их вроде бы хочется реализовать как utility class или helper class. То есть либо класс со статическими методами, либо в худшем случае синглтон, либо какое-то подобие, если средства языка позволяют это сделать выразительно.

Дальше получилось так: класс Utils::BashOperations, в котором есть статический метод git_clone, эмулирующий команду, при желании можно добавить статические методы для eslint и rubocop, которые в прод вызывают команды и возвращают какие-то специфические ответы. Что делает этот класс -- реализует вызовы несвязанных между собой команд, кроме того, там повторно используется метод run. Нужно ли его разнести на 4 файла, чтобы в одном был метод run, и три других метода в трех других файлах? Ну как будто бы это ничего хорошего не даст, никакого смыслового выигрыша, но понять такую структуру будет сложней.

Ну и понятно дело, моки они повторяют тот же интерфейс этого класса утилит (то есть ассортимент и сигнатуры методов), но предлагают другую реализацию. Если бы тут были интерфейсы в языке, то надо было бы от одного интерфейса их и унаследовать.

Также есть класс Utils::GithubOperations::Client. Который в случае с прод версией, пользуясь удобным синтаксисом руби просто представляет собой синоним другого типа. Ну а стаб реализует его как класс. Если не использовать этот синтаксис руби, а сделать по классике, то придется сделать отдельно класс утилиту, а отдельно реализовать класс стаба и в утилите статическим методом возвращить либо его, либо октокит. Но кажется это тоже никакого выигрыша в плане кода не дает, только больше файлов и сущностей. 

Поэтому вроде как сама структура не кажется кривой. 
Дописать заглушки к eslint и rubocop тоже наверное правильный путь. Но как будто бы остальные сомнения остались.

Обернуть инициализацию dry container в дочерний класс -- это сделал.

