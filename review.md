REVIEW 3

1. 

>> 2) По поводу статусов: поле aasm_state должно отображать статус проверки в модели Repository::Check, который отвечает за конкретную проверку. Соответственно нам не нужно отслеживать каждое событие, которое делается в рамках проверки, и эта информация избыточна. Мы проверяем проект, и нам не нужно подсвечивать, что клонируется репозиторий или уже склонировался, поэтому оптимальные статусы, это 

state :created, initial: true
state :checking, :finished, :failed
Необходимо поправить

>> 6) Более глубокие вопросы к архитектуре. Почему в CloneRepositoryService мы сначала действительно клонируем репозиторий, а потом вдруг запускаем проверку PerformCheckJob? Надо исходить из того, что сервис у нас должен совершать одно действие, важное правило - Single Responsibility Principle. И что же нам нужно глобально? Склонировать репозиторий или проверить проект? Я думаю второе, тогда почему бы не переименовать джобу в CheckRepositoryJob, сервис в CheckRepositoryService и в рамках уже проверки заниматься клонированием репозитория, который нам необходим для проверки. Необходимо исправить

В части завернуть ли мясо CloneJob в CloneService, ну для единобразия соглашусь, стоит это сделать.
А вот на счет объединить два сервиса в один и урезать статусы, тут прям дискуссионно. У меня сначала идет клонирование (CloneJob), в начале проставляется статус :cloning, в конце :cloned. Это отдельное действие с отдельным результатом -- копией кода. Если представить, что я захочу какие-то еще шаги по сборке делать, то клонирование как атомарное явление хоршо смотрится. Не всегда когда я клонирую, мне надо обязательно проверять. Поэтому как раз таки во имя Single responsibility я его и сделал отдельно. 

Если успех, то CloneJob запускает PerformCheckJob->, которая также ставит статус в начале, и в конце. Подход аналогичный, отдельное законченное действие, отдельный самоценный результат. И совершенно не важно откуда взялся проект, склонирован был или его туда CI/CD положил.

Почему так хорошо, так потому что я статусами ловню каждый этап и в теории могу его даже повторно запустить c нужного этапа, если он не критически сломался, состояние можно показать красиво, если web socket прикрутить. Можно какой-то еще этап вставить между, такми же образом реализованный, отдельно.

Что плохо, так это то, что они друг друга запускают по цепочке и нет оркестратора, который реализует логику комбинирования шагов. Но это все же тестовое задание, подумал я, когда делал.

Мне кажется если делать по уму, то надо делать окрестратор, который как раз будет вычитывать записи, готовые к выполнению одним из сервисов (:created, :cloned) и запускать следующий подходящий job.

Меня конечно не затруднит упростить как ты говоришь, но это как будто бы будет менее логично.

Упрощать?




6) Более глубокие вопросы к архитектуре. Почему в CloneRepositoryService мы сначала действительно клонируем репозиторий, а потом вдруг запускаем проверку PerformCheckJob? Надо исходить из того, что сервис у нас должен совершать одно действие, важное правило - Single Responsibility Principle. И что же нам нужно глобально? Склонировать репозиторий или проверить проект? Я думаю второе, тогда почему бы не переименовать джобу в CheckRepositoryJob, сервис в CheckRepositoryService и в рамках уже проверки заниматься клонированием репозитория, который нам необходим для проверки. Необходимо исправить


8) В production коде не должно быть проверок Rails.env.test?
Исключение тесты, конфиги и сиды, но это не тот случай

9) Необходимо визуально отделить константы от метода инициализации пропуском строки ссылка

10) То что сейчас называется GitService, должно называться Github::Client, это сервисный класс, который взаимодействует с гитхабом, и обрабатывает данные. Обычно окончание Service мы добавляем именно интеракторам, которые заточены под одно конкретное действие





6) Мы не должны делать костыли для автотестов. Если для теста приходиться делать костыль, значит косяк либо в архитектуре, либо в реализации теста. Возможно стоит пересмотреть логику или использовать моки в тестах

   Не должны, но это мы уже обсуждали. Почему автор тестового проекта решил из Создано сразу переводить в Успех нам неведомо.
   Там должно быть либо обработка либо ошибка.
